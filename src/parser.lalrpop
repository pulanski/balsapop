use crate::ast::*;
use crate::ReservedKeyword::Crate;

use crate::parser_errors::*;
// use colored::Colorize;

use lalrpop_util::ParseError;

grammar;

extern {
    type Error = InternalParserError;
}

// pub LiteralExpression: LiteralExpression = {
//     // <n: IntegerLiteral> => LiteralExpression::Integer{n},
//     // <f: FloatLiteral> => LiteralExpression::Float{f},
//     <s: StringLiteral> => LiteralExpression::String{s},
//     // <b: BoolLiteral> => LiteralExpression::Bool{b},
//     // <c: CharLiteral> => LiteralExpression::Char{c},
// }

//////////////////////////////////////////////////////////////////////////////
// Keywords (e.g. `as`, `if`, `else`, etc.) are not allowed as identifiers. //
//////////////////////////////////////////////////////////////////////////////

// "as"
pub(crate) Abstract: Keyword = {
    "abstract" => Keyword::Reserved(ReservedKeyword::Abstract),
}

// "as"
pub(crate) As: Keyword = {
    "as" => Keyword::As,
}

// "async"
pub(crate) Async: Keyword = {
    "async" => Keyword::Reserved(ReservedKeyword::Async),
}

// "await"
pub(crate) Await: Keyword = {
    "await" => Keyword::Reserved(ReservedKeyword::Await),
}

// "break"
pub(crate) Break: Keyword = {
    "break" => Keyword::Break,
}

// "const"
pub(crate) Const: Keyword = {
    "const" => Keyword::Const,
}

// "continue"
pub(crate) Continue: Keyword = {
    "continue" => Keyword::Continue,
}

// "crate"
pub(crate) Crate: Keyword = {
    "crate" => Keyword::Reserved(ReservedKeyword::Crate),
}

// "do"
pub(crate) Do: Keyword = {
    "do" => Keyword::Reserved(ReservedKeyword::Do),
}

// "dyn"
pub(crate) Dyn: Keyword = {
    "dyn" => Keyword::Reserved(ReservedKeyword::Dyn),
}

// "else"
pub(crate) Else: Keyword = {
    "else" => Keyword::Else,
}

// "enum"
pub(crate) Enum: Keyword = {
    "enum" => Keyword::Enum,
}

// "export"
pub(crate) Export: Keyword = {
    "export" => Keyword::Reserved(ReservedKeyword::Export),
}

// "extern"
pub(crate) Extern: Keyword = {
    "extern" => Keyword::Reserved(ReservedKeyword::Extern),
}

// "false"
pub(crate) False: Keyword = {
    "false" => Keyword::False,
}

// "final"
pub(crate) Final: Keyword = {
    "final" => Keyword::Reserved(ReservedKeyword::Final),
}

// "fn"
pub(crate) Fn: Keyword = {
    "fn" => Keyword::Fn,
}

// "for"
pub(crate) For: Keyword = {
    "for" => Keyword::For,
}

// "if"
pub(crate) If: Keyword = {
    "if" => Keyword::If,
}

// "impl"
pub(crate) Impl: Keyword = {
    "impl" => Keyword::Impl,
}

// "import"
pub(crate) Import: Keyword = {
    "import" => Keyword::Reserved(ReservedKeyword::Import),
}

// "in"
pub(crate) In: Keyword = {
    "in" => Keyword::In,
}

// "let"
pub(crate) Let: Keyword = {
    "let" => Keyword::Reserved(ReservedKeyword::Let),
}

// "loop"
pub(crate) Loop: Keyword = {
    "loop" => Keyword::Loop,
}

// "macro"
pub(crate) Macro: Keyword = {
    "macro" => Keyword::Reserved(ReservedKeyword::Macro),
}

// "match"
pub(crate) Match: Keyword = {
    "match" => Keyword::Match,
}

// "mod"
pub(crate) Mod: Keyword = {
    "mod" => Keyword::Mod,
}

// "move"
pub(crate) Move: Keyword = {
    "move" => Keyword::Reserved(ReservedKeyword::Move),
}

// "mut"
pub(crate) Mut: Keyword = {
    "mut" => Keyword::Reserved(ReservedKeyword::Mut),
}

// "Override"
pub(crate) Override: Keyword = {
    "override" => Keyword::Reserved(ReservedKeyword::Override),
}

// "priv"
pub(crate) Priv: Keyword = {
    "priv" => Keyword::Reserved(ReservedKeyword::Priv),
}

// "proc"
pub(crate) Proc: Keyword = {
    "proc" => Keyword::Reserved(ReservedKeyword::Proc),
}

// "pub"
pub(crate) Pub: Keyword = {
    "pub" => Keyword::Pub,
}

// "ref"
pub(crate) Ref: Keyword = {
    "ref" => Keyword::Reserved(ReservedKeyword::Ref),
}

// "return"
pub(crate) Return: Keyword = {
    "return" => Keyword::Return,
}

// "self"
pub(crate) SelfValue: Keyword = {
    "self" => Keyword::SelfValue,
}

// "Self"
pub(crate) SelfType: Keyword = {
    "Self" => Keyword::SelfType,
}

// "static"
pub(crate) Static: Keyword = {
    "static" => Keyword::Static,
}

// "struct"
pub(crate) Struct: Keyword = {
    "struct" => Keyword::Struct,
}

// "super"
pub(crate) Super: Keyword = {
    "super" => Keyword::Super,
}

// "trait"
pub(crate) Trait: Keyword = {
    "trait" => Keyword::Trait,
}

// "true"
pub(crate) True: Keyword = {
    "true" => Keyword::True,
}

// "type"
pub(crate) Type: Keyword = {
    "type" => Keyword::Type,
}

// "typeof"
pub(crate) Typeof: Keyword = {
    "typeof" => Keyword::Reserved(ReservedKeyword::Typeof),
}

// "unsafe"
pub(crate) Unsafe: Keyword = {
    "unsafe" => Keyword::Reserved(ReservedKeyword::Unsafe),
}

// "unsized"
pub(crate) Unsized: Keyword = {
    "unsized" => Keyword::Reserved(ReservedKeyword::Unsized),
}

// "use"
pub(crate) Use: Keyword = {
    "use" => Keyword::Use,
}

// "virtual"
pub(crate) Virtual: Keyword = {
    "virtual" => Keyword::Reserved(ReservedKeyword::Virtual),
}

// "where"
pub(crate) Where: Keyword = {
    "where" => Keyword::Where,
}

// "while"
pub(crate) While: Keyword = {
    "while" => Keyword::While,
}

// "yield"
pub(crate) Yield: Keyword = {
    "yield" => Keyword::Reserved(ReservedKeyword::Yield),
}

// IDENTIFIER_OR_KEYWORD :
//       XID_Start XID_Continue*
//    | _ XID_Continue+
// pub(crate) Identifier: String = {
//     <identifier:IdentifierStart> <identifier:IdentifierContinue>* => identifier,
// }

// pub(crate) IdentifierStart: String = {
//     <identifier_start:r"\p{Nd}+([[:WB=MB:][:WB=MN:]]\p{Nd}+)?"> => identifier_start.to_string(),
// }

///////////////////////////////////
// Character and String Literals //
///////////////////////////////////

// pub(crate) CharLiteral: char = {
//     <left_apostrophe:Apostrophe> <character:r"[^\n\r\t'\\]"> <right_apostrophe:Apostrophe> => character.chars().next().unwrap(),
// }

////////////////////////////////////////////////
// Character and String Literal symbol tokens //
////////////////////////////////////////////////

// UNICODE_ESCAPE :
//    \u{ ( HEX_DIGIT _* )1..6 }

// pub(crate) UnicodeEscape: String = {
//     <left_backslash:Backslash> <u:U> <left_brace:LeftBrace> <digits:HexDigit> <digits:HexDigit>* <right_brace:RightBrace> => {
//         let mut s = String::new();
//         s.push(left_backslash);
//         s.push(u);
//         s.push(left_brace);
//         s.push_str(&digits);
//         s.push(right_brace);
//         s
//     },
// }

// "\u"
pub(crate) UnicodeEscapePrefix: String = {
    <left_backslash:Backslash> <u:"u"> => {
        let mut s = String::new();
        s.push_str("\\");
        s.push_str(&u);
        s
    },
}

pub(crate) Apostrophe: char = {
    <apostrophe:"'"> => apostrophe.chars().next().unwrap(),
}

pub(crate) Quote: char = {
    <quote:"\""> => quote.chars().next().unwrap(),
}

// TODO maybe in the future refactor to incorporating the following
// into the parsing strategy of String and Charater literals

// pub(crate) QuoteEscape: String = {
//     <esc:r"\'"> => String::from(esc),
//     <esc:r#"\""#> => String::from(esc),
// }

// pub(crate) UnicodeEscape = {
//     <"\\u{" n: HexDigit+ "}" > => {
//         let n = u32::from_str_radix(n, 16).unwrap();
//         char::from_u32(n).unwrap()
//     },
//     <"\\u" n: HexDigit{4} > => {
//         let n = u32::from_str_radix(n, 16).unwrap();
//         char::from_u32(n).unwrap()
//     },
// }

StringLiteral: String = {
    <s:r#""[^"]*""#> => s.to_string()[1..s.len() - 1].to_string(),
}

///////////////////////////////
// Numeric Literals          //
//                           //
// - Integer Literals        //
// - Floating Point Literals //
// - Mathematic Constants    //
///////////////////////////////

// TODO PICK A GRAMMAR NOTATION, EITHER EBNF OR WIRTH
/////////////////////////////////////////////////////////////////////////////////////
// Integer Literals                                                                //
//                                                                                 //
// Lexer                                                                           //
//                                                                                 //
// Grammar:                                                                        //
//   IntegerLiteral = (DecimalLiteral | BinaryLiteral | OctalLiteral               //
//                     | HexadecimalLiteral ) IntegerSuffix?                       //
//   DecimalLiteral = DecimalDigit DecimalDigitOrUnderscore*                       //
//   HexadecimalLiteral = HexadecimalLiteralPrefix HexadecimalDigitOrUnderscore*   //
//                   HexadecimalDigit HexadecimalDigitOrUnderscore*                //
//   OctalLiteral = OctalLiteralPrefix OctalDigitOrUnderscore* OctalDigit          //
//                   OctalDigitOrUnderscore*                                       //
//   BinaryLiteral = BinaryLiteralPrefix BinaryDigitOrUnderscore* BinaryDigit      //
//                   BinaryDigitOrUnderscore*                                      //
//   HexadecimalDigitOrUnderscore = HexadecimalDigit | Score                       //
//   BinaryDigitOrUnderscore = BinaryDigit | Underscore                            //
//   HexadecimalDigit = OctalDigit | "8".."9" | "a".."f" | "A".."F"                //
//   OctalDigit = BinaryDigit | "2".."7"                                           //
//   BinaryDigit = "0" | "1"                                                       //
//   HexadecimalLiteralPrefix = "0x" OR "0x" | "0X" <- TODO maybe use this instead //
//   OctalLiteralPrefix = "0b" OR "0o" | "0O" <- TODO maybe use this instead       //
//   BinaryLiteralPrefix = "0b" OR "0b" | "0B" <- TODO maybe use this instead      //
//   IntegerSuffix = "i8" | "i16" | "i32" | "i64" | `i128" | "isize"               //
//                 | "u8" | "u16" | "u32" | "u64" | "u128" | "usize"               //
/////////////////////////////////////////////////////////////////////////////////////

// NOTE: All integer literals are parsed as u128, and then casted to the appropriate type later (if needed). This is done to allow for the largest possible integer literal to be parsed. The largest possible integer literal is 128 bits, which is the size of a u128. We don't care about the sign of the integer literal, so we can just parse it as unsigned. The sign will be determined by the greater context in which the integer literal is used (i.e. NegationExpression).

// TODO change parsing for type suffixes to be more robust
pub(crate) IntegerLiteral: u128 = {
    <hexadecimal_literal:HexadecimalLiteral> IntegerSuffix? => hexadecimal_literal,
    <decimal_literal:DecimalLiteral> IntegerSuffix? => decimal_literal,
    <octal_literal:OctalLiteral> IntegerSuffix? => octal_literal,
    <binary_literal:BinaryLiteral> IntegerSuffix? => binary_literal,
}


pub(crate) HexadecimalLiteral: u128 = {
    <hexadecimal_prefix:HexadecimalLiteralPrefix> <hexadecimal_digits:HexadecimalDigitOrUnderscore+> => {
        let mut hexadecimal_digits = hexadecimal_digits;
        hexadecimal_digits.reverse();
        let mut result = 0;
        let mut digit_count = 0;
        for (i, d) in hexadecimal_digits.iter().enumerate() {
            if d == &'_' {
                continue;
            }
            match d {
                '0' => {},
                '1' => {result += 1 * 16_u128.pow(digit_count as u32);},
                '2' => {result += 2 * 16_u128.pow(digit_count as u32);},
                '3' => {result += 3 * 16_u128.pow(digit_count as u32);},
                '4' => {result += 4 * 16_u128.pow(digit_count as u32);},
                '5' => {result += 5 * 16_u128.pow(digit_count as u32);},
                '6' => {result += 6 * 16_u128.pow(digit_count as u32);},
                '7' => {result += 7 * 16_u128.pow(digit_count as u32);},
                '8' => {result += 8 * 16_u128.pow(digit_count as u32);},
                '9' => {result += 9 * 16_u128.pow(digit_count as u32);},
                'a' => {result += 10 * 16_u128.pow(digit_count as u32);},
                'b' => {result += 11 * 16_u128.pow(digit_count as u32);},
                'c' => {result += 12 * 16_u128.pow(digit_count as u32);},
                'd' => {result += 13 * 16_u128.pow(digit_count as u32);},
                'e' => {result += 14 * 16_u128.pow(digit_count as u32);},
                'f' => {result += 15 * 16_u128.pow(digit_count as u32);},
                'A' => {result += 10 * 16_u128.pow(digit_count as u32);},
                'B' => {result += 11 * 16_u128.pow(digit_count as u32);},
                'C' => {result += 12 * 16_u128.pow(digit_count as u32);},
                'D' => {result += 13 * 16_u128.pow(digit_count as u32);},
                'E' => {result += 14 * 16_u128.pow(digit_count as u32);},
                'F' => {result += 15 * 16_u128.pow(digit_count as u32);},
                _ => unreachable!(),
            }
            digit_count += 1;
        }
        // if result is larger than u128::MAX, then it is an error
        if result > u128::MAX {
            panic!("Integer literal is too large");
        }
// 340_282_366_920_938_463_463_374_607_431_768_211_455u128
        result as u128
    }
}

// DEC_LITERAL :
//    DEC_DIGIT (DEC_DIGIT|_)*
pub(crate) DecimalLiteral: u128 = {
    <start_decimal_digit:DecimalDigit> <end_decimal_digits:DecimalDigitOrUnderscore*> => {
        let mut result = String::from(start_decimal_digit);
        for decimal_digit in end_decimal_digits {
            if decimal_digit == '_' {
                continue;
            }
            result.push(decimal_digit);
        }
        // if result is larger than u128::MAX, then it is an error
        // if result > u128::MAX {
        //     panic!("Integer literal is too large");
        // }
        return result.parse::<u128>().unwrap();
    }
}

//     // <decimal_digits:DecimalDigitOrUnderscore+> => {
    //     let decimal_digits = decimal_digits.iter().filter(|&&d| d != '_').collect::<String>();
    //     decimal_digits.parse().unwrap()
    // }

// TODO SHOULD BE REFACTORED TO OctalLiteralPrefix OctalDigitOrUnderscore* OctalDigit OctalDigitOrUnderscore*
// OctalLiteralPrefix OctalDigitOrUnderscore*
pub(crate) OctalLiteral: u128 = {
    <octal_prefix:OctalLiteralPrefix> <octal_digits:OctalDigitOrUnderscore+> => {
        let mut octal_digits = octal_digits;
        octal_digits.reverse();
        let mut result = 0;
        let mut digit_count = 0;
        for (i, d) in octal_digits.iter().enumerate() {
            if d == &'_' {
                continue;
            }

            result += d.to_digit(8).unwrap() * 8_u32.pow(digit_count as u32);
            digit_count += 1;
        }
        result as u128
    }
}

// TODO in the future refactor to where BinaryLiteral is lexed with the following production:
// BinaryLiteral = BinaryLiteralPrefix BinaryDigitOrUnderscore* BinaryDigit BinaryDigitOrUnderscore*
// Currently this is not working (not sure why) so I am using the following production:
// BinaryLiteral = BinaryLiteralPrefix BinaryDigitOrUnderscore*
// However, this is not correct because it allows for `0b_` to be a valid binary literal. Right now this case is being parsed to 0.
// _ -> 0
pub(crate) BinaryLiteral: u128 = {
    <binary_prefix:BinaryLiteralPrefix> <binary_digits:BinaryDigitOrUnderscore+> => {
        // We must redeclare each of the variables coming from the nonterminals in the grammar as mutable, because they are immutable by default.
        let mut binary_digits = binary_digits;
        binary_digits.reverse();
        let mut result = 0;
        let mut digit_count = 0;
        for d in binary_digits {
            if d == '_' {
                continue;
            }
            result += d.to_digit(10).unwrap() * 2u32.pow(digit_count as u32);
            digit_count += 1;
        }
        result as u128
    }
}

// HexadecimalDigit | Underscore
pub(crate) HexadecimalDigitOrUnderscore: char = {
    <hexadecimal_digit:HexadecimalDigit> => hexadecimal_digit,
    <underscore:Underscore> => '_',
}

// DecimalDigit | Underscore
pub(crate) DecimalDigitOrUnderscore: char = {
    <decimal_digit:DecimalDigit> => decimal_digit,
    <underscore:Underscore> => '_',
}

// OctalDigit | Underscore
pub(crate) OctalDigitOrUnderscore: char = {
    <octal_digit:OctalDigit> => octal_digit,
    <underscore:Underscore> => '_',
}

// BinaryDigit | Underscore
pub(crate) BinaryDigitOrUnderscore: char = {
    <binary_digit:BinaryDigit> => binary_digit,
    <underscore:Underscore> => '_',
}

// "0".."9" | "a".."f" | "A".."F"
pub(crate) HexadecimalDigit: char = {
    <d:DecimalDigit> => d,
    <e:ExponentialSymbol> => e,
    <h:r"[a-dfA-DF]"> => h.chars().next().unwrap(),
}

// "0".."9"
pub(crate) DecimalDigit: char = {
    <o:OctalDigit> => o,
    <d:r"8|9"> => d.chars().next().unwrap(),
}

// "0".."7"
pub(crate) OctalDigit: char = {
    <b:BinaryDigit> => b,
    <o:r"2|3|4|5|6|7"> => o.chars().next().unwrap(),
}

// "0" | "1"
pub(crate) BinaryDigit: char = {
    <b:r"0|1"> => b.chars().next().unwrap(),
}

// "0b" | "0B"
pub(crate) BinaryLiteralPrefix: String = {
    <b:r"0b"> => b.to_string(),
    <b:r"0B"> => b.to_string(),
}

// "0o" | "0O"
pub(crate) OctalLiteralPrefix: String = {
    <o:r"0o"> => o.to_string(),
    <o:r"0O"> => o.to_string(),
}

// "0x" | "0X"
pub(crate) HexadecimalLiteralPrefix: String = {
    <h:r"0x"> => h.to_string(),
    <h:r"0X"> => h.to_string(),
}

// "u8" | "u16" | "u32" | "u64" | "u128" | "usize"
// | "i8" | "i16" | "i32" | "i64" | "i128" | "isize"
pub(crate) IntegerSuffix: String = {
    <integer_suffix:r"u8|u16|u32|u64|u128|usize|i8|i16|i32|i64|i128|isize"> => integer_suffix.to_string(),
}

////////////////////
// Float Literals //
////////////////////

// FLOAT_LITERAL :
//       DEC_LITERAL . (not immediately followed by ., _ or an XID_Start character)
//    | DEC_LITERAL FLOAT_EXPONENT
//    | DEC_LITERAL . DEC_LITERAL FLOAT_EXPONENT?
//    | DEC_LITERAL (. DEC_LITERAL)? FLOAT_EXPONENT? FLOAT_SUFFIX
pub(crate) FloatLiteral: f64 = {
    <start_decimal_literal:DecimalLiteral> <dot:Dot> <end_decimal_literal:DecimalLiteral> <exponent:FloatExponent?> => {
        let mut result = start_decimal_literal.to_string();
        result.push('.');
        result.push_str(&end_decimal_literal.to_string());
        if let Some(exponent) = exponent {
            result.push_str(&exponent.to_string());
        }
        result.parse::<f64>().unwrap()
    },
    <decimal_literal:DecimalLiteral> <exponent:FloatExponent> => {
        let mut result = decimal_literal.to_string();
        result.push_str(&exponent.to_string().replace("_", ""));
        result.parse::<f64>().unwrap()
    },
    <decimal_literal:DecimalLiteral> <dot:Dot> => {
        let mut result = decimal_literal.to_string();
        result.push('.');
        result.parse::<f64>().unwrap()
    },
}

//  (e|E) (+|-)? (DEC_DIGIT|_)* DEC_DIGIT (DEC_DIGIT|_)* <-- TODO SHOULD BE REFACTORED TO THIS PRODUCTION
// (e|E) (+|-)? (DEC_DIGIT|_)+ <-- CURRENTLY USING THIS PRODUCTION (due to ambiguity in the above production from the parser)
pub(crate) FloatExponent: String = {
    <exponential_symbol:ExponentialSymbol> <sign:PlusOrMinusSign?> <decimal_digits:DecimalDigitOrUnderscore+> =>? {
        let mut result = String::new();

        // check if decimal_digits contains at least one digit
        if !decimal_digits.iter().any(|d| d.is_digit(10)) {
            return Err(ParseError::User {
                error: InternalParserError::InvalidFloatExponent
            })
        }

        result.push(exponential_symbol);
        if let Some(sign) = sign {
            result.push(sign);
        }

        for d in decimal_digits {
            result.push(d);
        }
        Ok(result)
    }
}

// "e" | "E"
pub(crate) ExponentialSymbol: char = {
    <e:r"e|E"> => e.chars().next().unwrap(),
}

// "+" | "-"
pub(crate) PlusOrMinusSign: char = {
    <sign:Plus> => '+',
    <sign:Minus> => '-',
}

// "f32" | "f64"
pub(crate) FloatSuffix: String = {
    <float_suffix:r"f32|f64"> => float_suffix.to_string(),
}

////////////////////////////
// Mathematical Constants //
////////////////////////////

// "pi" | "π" | "tau" | "τ" | "e"

// PiLiteral := PiSymbol PiSuffix?
// PiSymbol := "pi" | "π"
// PiSuffix := "_" <decimal_digits:DecimalDigit+> where decimal_digits is < 15
// TauLiteral := TauSymbol TauSuffix?

// TODO MathematicalConstant: MathematicalConstant = {

// "pi" | "π" | "𝜋"
pub(crate) Pi: MathematicalConstant  = {
    <pi:r"pi|π|𝜋"> => MathematicalConstant::Pi {
        value: std::f64::consts::PI,
    },
}

// "euler" | "ℯ"
pub(crate) Euler: MathematicalConstant = {
    <euler:r"euler|ℯ"> => MathematicalConstant::Euler {
        value: std::f64::consts::E,
    },
}

// "tau" | "τ" | "𝜏"
pub(crate) Tau: MathematicalConstant = {
    <tau:r"tau|τ|𝜏"> => MathematicalConstant::Tau {
        value: std::f64::consts::TAU,
    },
}

// "phi" | "φ" | "𝜙"
pub(crate) GoldenRatio: MathematicalConstant = {
    <golden:r"golden|φ|𝜙"> => MathematicalConstant::GoldenRatio {
        value: 1.618033988749895,
    },
}

// "catalan" | "𝜆"
pub(crate) Catalan: MathematicalConstant = {
    <catalan:"catalan"> => MathematicalConstant::Catalan {
        value: 0.915965594177219,
    },
}

// "eulergamma" | "γ" | "𝛾" | "eulermascheroni"
pub(crate) EulerMascheroni: MathematicalConstant = {
    <eulermascheroni:r"eulermascheroni|γ|𝛾|eulergamma"> => MathematicalConstant::EulerMascheroni {
        value: 0.5772156649015329,
    },
}

// "Inf" | "∞"
pub(crate) Infinity: MathematicalConstant = {
    <infinity:r"Inf|∞"> => MathematicalConstant::Infinity {
        value: std::f64::INFINITY,
    },
}

// "NaN"
pub(crate) NotANumber: MathematicalConstant = {
    <nan:"NaN"> => MathematicalConstant::NotANumber
}

//////////////
// Comments //
//////////////

// LINE_COMMENT :
//    //   (~[/ !] | //) ~\n*
//    | //
pub(crate) LineComment: Comment = {
    <comment:r"//([^/!]|//)[^\n]*"> => Comment::LineComment {
        comment: String::from(comment),
    },
    <comment:"//"> => Comment::LineComment {
        comment: String::from(comment),
    },
}

// BLOCK_COMMENT :
//    /* (~[*!] | **) (~*/) ~[*]*/
//    | /**/
//    | /***/
pub(crate) BlockComment: Comment = {
    <comment:r"/\*([^*!]|\*\*)[^*]*\*/"> => Comment::BlockComment {
        comment: String::from(comment),
    },
    <comment:"/**/"> => Comment::BlockComment {
        comment: String::from(comment),
    },
    <comment:"/***/"> => Comment::BlockComment {
        comment: String::from(comment),
    },
}

// OUTER_LINE_DOC :
   /// (~/ ~[\n]*)?
pub(crate) OuterLineDocComment: Comment = {
    <comment:r"///([^/][^\n]*)?"> => Comment::DocComment(DocComment::OuterLineDocComment {
        comment: String::from(comment),
    }),
}

// INNER_LINE_DOC :
//    //! ~[\n]*
pub(crate) InnerLineDocComment: Comment = {
    <comment:r"//![^\n]*"> => Comment::DocComment(DocComment::InnerLineDocComment {
        comment: String::from(comment),
    }),
}

// INNER_BLOCK_DOC :
//    /*! ( BlockCommentOrDoc | ~[*/] )* */
pub(crate) InnerBlockDocComment: String = {
    <comment:r"/\*!([^\*/])*\*/"> => String::from(comment),
}

// OUTER_BLOCK_DOC :
//    /** (~* | BlockCommentOrDoc ) (BlockCommentOrDoc | ~[*/])* */

// BlockCommentOrDoc :
//       BLOCK_COMMENT
//    | OUTER_BLOCK_DOC
//    | INNER_BLOCK_DOC

///////////
// Paths //
///////////

// SimplePath : SimplePathSegment ("::" PathSegment)*
// pub(crate) SimplePath: SimplePath = {
//     <path:SimplePathSegment> <rest:("::" SimplePathSegment)*> => {
//         let mut path = path;
//         for segment in rest {
//             path.segments.push(segment.1);
//         }
//         Path::SimplePath(path)
//     },
// }

// SimplePathSegment : Identifier | "super" | "self" | "crate"
// pub(crate) SimplePathSegment: SimplePathSegment = {
//     // <ident:Identifier> => SimplePathSegment::Identifier(ident),
//     // <super:Super> => SimplePathSegment::SuperSegment {
//     //     segment: String::from("super"),
//     // },
//     // <self:SelfValue> => SimplePathSegment::SelfValueSegment {
//     //     segment: String::from("self"),
//     // },
//     // <crate:Crate> => SimplePathSegment::CrateSegment {
//     //     segment: String::from("crate"),
//     // },
// }

///////////////////////////////
// Punctuation symbol tokens //
///////////////////////////////

pub(crate) Plus: Punctuation = {
    <plus:"+"> => Punctuation::Plus,
}

pub(crate) Minus: Punctuation = {
    <minus:"-"> => Punctuation::Minus,
}

pub(crate) Star: Punctuation = {
    <star:"*"> => Punctuation::Star,
}

pub(crate) Slash: Punctuation = {
    <slash:"/"> => Punctuation::Slash,
}

pub(crate) Backslash: Punctuation = {
    <backslash:"\\"> => Punctuation::Backslash,
}

pub(crate) Percent: Punctuation = {
    <percent:"%"> => Punctuation::Percent,
}

pub(crate) Caret: Punctuation = {
    <caret:"^"> => Punctuation::Caret,
}

pub(crate) Not: Punctuation = {
    <not:"!"> => Punctuation::Not,
}

pub(crate) And: Punctuation = {
    <and:"&"> => Punctuation::And,
}

pub(crate) Or: Punctuation = {
    <or:"|"> => Punctuation::Or,
}

pub(crate) AndAnd: Punctuation = {
    <and_and:"&&"> => Punctuation::AndAnd,
}

pub(crate) OrOr: Punctuation = {
    <or_or:"||"> => Punctuation::OrOr,
}

pub(crate) PlusEquals: Punctuation = {
    <plus_equals:"+="> => Punctuation::PlusEquals,
}

pub(crate) MinusEquals: Punctuation = {
    <minus_equals:"-="> => Punctuation::MinusEquals,
}

pub(crate) StarEquals: Punctuation = {
    <star_equals:"*="> => Punctuation::StarEquals,
}

pub(crate) SlashEquals: Punctuation = {
    <slash_equals:"/="> => Punctuation::SlashEquals,
}

pub(crate) PercentEquals: Punctuation = {
    <percent_equals:"%="> => Punctuation::PercentEquals,
}

pub(crate) CaretEquals: Punctuation = {
    <caret_equals:"^="> => Punctuation::CaretEquals,
}

pub(crate) AndEquals: Punctuation = {
    <and_equals:"&="> => Punctuation::AndEquals,
}

pub(crate) OrEquals: Punctuation = {
    <or_equals:"|="> => Punctuation::OrEquals,
}

pub(crate) Equals: Punctuation = {
    <equals:"="> => Punctuation::Equals,
}

pub(crate) DoubleEquals: Punctuation = {
    <double_equals:"=="> => Punctuation::DoubleEquals,
}

pub(crate) NotEqual: Punctuation = {
    <not_equal:r"!=|≠"> => Punctuation::NotEqual,
}

pub(crate) LessThan: Punctuation = {
    <less_than:"<"> => Punctuation::LessThan,
}

pub(crate) LessThanEqual: Punctuation = {
    <less_than_equal:r"<=|≤"> => Punctuation::LessThanEqual,
}

pub(crate) GreaterThan: Punctuation = {
    <greater_than:">"> => Punctuation::GreaterThan,
}

pub(crate) GreaterThanEqual: Punctuation = {
    <greater_than_equal:r">=|≥"> => Punctuation::GreaterThanEqual,
}

pub(crate) Underscore: Punctuation = {
    <underscore:"_"> => Punctuation::Underscore,
}

pub(crate) Dot: Punctuation = {
    <dot:"."> => Punctuation::Dot,
}

pub(crate) DotDot: Punctuation = {
    <dot_dot:".."> => Punctuation::DotDot,
}

pub(crate) DotDotDot: Punctuation = {
    <dot_dot_dot:"..."> => Punctuation::DotDotDot,
}

pub(crate) DotDotEquals: Punctuation = {
    <dot_dot_equals:"..="> => Punctuation::DotDotEquals,
}

pub(crate) Comma: Punctuation = {
    <comma:","> => Punctuation::Comma,
}

pub(crate) Colon: Punctuation = {
    <colon:":"> => Punctuation::Colon,
}

pub(crate) Semicolon: Punctuation = {
    <semicolon:";"> => Punctuation::Semicolon,
}

pub(crate) PathSeparator: Punctuation = {
    <path_separator:"::"> => Punctuation::PathSeparator,
}

pub(crate) RightArrow: Punctuation = {
    <right_arrow:r"->|→"> => Punctuation::RightArrow,
}

pub(crate) LeftArrow: Punctuation = {
    <left_arrow:r"<-|←"> => Punctuation::LeftArrow,
}

pub(crate) FatRightArrow: Punctuation = {
    <fat_right_arrow:r"=>|⇒"> => Punctuation::FatRightArrow,
}

pub(crate) FatLeftArrow: Punctuation = {
    <fat_left_arrow:r"⇐"> => Punctuation::FatLeftArrow,
}

pub(crate) Pound: Punctuation = {
    <pound:"#"> => Punctuation::Pound,
}

pub(crate) Dollar: Punctuation = {
    <dollar:"$"> => Punctuation::Dollar,
}

pub(crate) Question: Punctuation = {
    <question:"?"> => Punctuation::Question,
}

/////////////////////////////
// Delimiter symbol tokens //
/////////////////////////////

pub(crate) LeftParen: Delimiter = {
    <left_paren:"("> => Delimiter::LeftParen,
}
pub(crate) RightParen: Delimiter = {
    <right_paren:")"> => Delimiter::RightParen,
}

pub(crate) LeftBracket: Delimiter = {
    <left_bracket:"["> => Delimiter::LeftBracket,
}

pub(crate) RightBracket: Delimiter = {
    <right_bracket:"]"> => Delimiter::RightBracket,
}

pub(crate) LeftBrace: Delimiter = {
    <left_brace:"{"> => Delimiter::LeftBrace,
}

pub(crate) RightBrace: Delimiter = {
    <right_brace:"}"> => Delimiter::RightBrace,
}

match {
    r"\s*" => {}, // ignore whitespace
    // r"//.*" => {}, // ignore comments
    // r"//[^\n\r]*[\n\r]*" => {}, // ignore comments
    // This `_` means "add in all the other strings and
    // regular expressions in the grammer here" (e.g.,
    // `(`).
    _
}

// match {
//     // These items have highest precedence.
//     // r"\p{Nd}+([[:WB=MB:][:WB=MN:]]\p{Nd}+)?",
//     r"[^\n\r\t'\\]"
//     // These items have next highest precedence.
// } else {
//     // These items have next highest precedence.
//     r"0|1",
//     r"\s*" => {}, // ignore whitespace
//     // r"//.*" => {}, // ignore comments
//     r"//[^\n\r]*[\n\r]*" => {}, // ignore comments
//     // This `_` means "add in all the other strings and
//     // regular expressions in the grammer here" (e.g.,
//     // `(`).
//     _
// } // you can have more `else` sections if you like
