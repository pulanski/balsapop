use crate::ast::*;

grammar;

pub LiteralExpression: LiteralExpression = {
    // <n: IntegerLiteral> => LiteralExpression::Integer{n},
    <f: FloatLiteral> => LiteralExpression::Float{f},
    <s: StringLiteral> => LiteralExpression::String{s},
    // <b: BoolLiteral> => LiteralExpression::Bool{b},
    // <c: CharLiteral> => LiteralExpression::Char{c},
}

// IntegerLiteral: i64 = {
//     <n:r"[+-]?[0-9]+">
//         => n.parse().unwrap(),
// }

FloatLiteral: f64 = {
    <f:r"[+-]?([0-9]+(([.][0-9]*)|([.][0-9]+)))[e|E]?[+|-]?[0-9]+">
        => f.parse().unwrap(),
}

StringLiteral: String = {
    <s:r#""[^"]*""#> => s.to_string()[1..s.len() - 1].to_string(),
}

// DEC_LITERAL: u64 = {
//     <digits:DIGIT+> => {
//         digits.iter().fold(0, |acc, &d| acc * 10 + d as u64)
//     }
// }

///////////////////////////////
// Numeric Literals          //
//                           //
// - Integer Literals        //
// - Floating Point Literals //
// - Mathematic Constants    //
///////////////////////////////

// TODO PICK A GRAMMAR NOTATION, EITHER EBNF OR WIRTH
/////////////////////////////////////////////////////////////////////////////////////
// Integer Literals                                                                //
//                                                                                 //
// Lexer                                                                           //
//                                                                                 //
// Grammar:                                                                        //
//   IntegerLiteral = (DecimalLiteral | BinaryLiteral | OctalLiteral               //
//                     | HexadecimalLiteral ) IntegerSuffix?                       //
//   DecimalLiteral = DecimalDigit DecimalDigitOrUnderscore*                       //
//   HexadecimalLiteral = HexadecimalLiteralPrefix HexadecimalDigitOrUnderscore*   //
//                   HexadecimalDigit HexadecimalDigitOrUnderscore*                //
//   OctalLiteral = OctalLiteralPrefix OctalDigitOrUnderscore* OctalDigit          //
//                   OctalDigitOrUnderscore*                                       //
//   BinaryLiteral = BinaryLiteralPrefix BinaryDigitOrUnderscore* BinaryDigit      //
//                   BinaryDigitOrUnderscore*                                      //
//   HexadecimalDigitOrUnderscore = HexadecimalDigit | Score                       //
//   BinaryDigitOrUnderscore = BinaryDigit | Underscore                            //
//   HexadecimalDigit = OctalDigit | "8".."9" | "a".."f" | "A".."F"                //
//   OctalDigit = BinaryDigit | "2".."7"                                           //
//   BinaryDigit = "0" | "1"                                                       //
//   HexadecimalLiteralPrefix = "0x" OR "0x" | "0X" <- TODO maybe use this instead //
//   OctalLiteralPrefix = "0b" OR "0o" | "0O" <- TODO maybe use this instead       //
//   BinaryLiteralPrefix = "0b" OR "0b" | "0B" <- TODO maybe use this instead      //
//   IntegerSuffix = "i8" | "i16" | "i32" | "i64" | `i128" | "isize"               //
//                 | "u8" | "u16" | "u32" | "u64" | "u128" | "usize"               //
/////////////////////////////////////////////////////////////////////////////////////

// NOTE: All integer literals are parsed as u128, and then casted to the appropriate type later (if needed). This is done to allow for the largest possible integer literal to be parsed. The largest possible integer literal is 128 bits, which is the size of a u128. We don't care about the sign of the integer literal, so we can just parse it as unsigned. The sign will be determined by the greater context in which the integer literal is used (i.e. NegationExpression).

// TODO change parsing for type suffixes to be more robust
pub(crate) IntegerLiteral: u128 = {
    <hexadecimal_literal:HexadecimalLiteral> IntegerSuffix? => hexadecimal_literal,
    <decimal_literal:DecimalLiteral> IntegerSuffix? => decimal_literal,
    <octal_literal:OctalLiteral> IntegerSuffix? => octal_literal,
    <binary_literal:BinaryLiteral> IntegerSuffix? => binary_literal,
}

pub(crate) HexadecimalLiteral: u128 = {
    <hexadecimal_prefix:HexadecimalLiteralPrefix> <hexadecimal_digits:HexadecimalDigitOrUnderscore+> => {
        let mut hexadecimal_digits = hexadecimal_digits;
        hexadecimal_digits.reverse();
        let mut result = 0;
        let mut digit_count = 0;
        for (i, d) in hexadecimal_digits.iter().enumerate() {
            if d == &'_' {
                continue;
            }
            match d {
                '0' => {},
                '1' => {result += 1 * 16_u128.pow(digit_count as u32);},
                '2' => {result += 2 * 16_u128.pow(digit_count as u32);},
                '3' => {result += 3 * 16_u128.pow(digit_count as u32);},
                '4' => {result += 4 * 16_u128.pow(digit_count as u32);},
                '5' => {result += 5 * 16_u128.pow(digit_count as u32);},
                '6' => {result += 6 * 16_u128.pow(digit_count as u32);},
                '7' => {result += 7 * 16_u128.pow(digit_count as u32);},
                '8' => {result += 8 * 16_u128.pow(digit_count as u32);},
                '9' => {result += 9 * 16_u128.pow(digit_count as u32);},
                'a' => {result += 10 * 16_u128.pow(digit_count as u32);},
                'b' => {result += 11 * 16_u128.pow(digit_count as u32);},
                'c' => {result += 12 * 16_u128.pow(digit_count as u32);},
                'd' => {result += 13 * 16_u128.pow(digit_count as u32);},
                'e' => {result += 14 * 16_u128.pow(digit_count as u32);},
                'f' => {result += 15 * 16_u128.pow(digit_count as u32);},
                'A' => {result += 10 * 16_u128.pow(digit_count as u32);},
                'B' => {result += 11 * 16_u128.pow(digit_count as u32);},
                'C' => {result += 12 * 16_u128.pow(digit_count as u32);},
                'D' => {result += 13 * 16_u128.pow(digit_count as u32);},
                'E' => {result += 14 * 16_u128.pow(digit_count as u32);},
                'F' => {result += 15 * 16_u128.pow(digit_count as u32);},
                _ => {panic!("Invalid hexadecimal digit: {}", d);},
            }
            digit_count += 1;
        }
        result as u128
    }
}

pub(crate) DecimalLiteral: u128 = {
    <decimal_digits:DecimalDigitOrUnderscore+> => {
        let decimal_digits = decimal_digits.iter().filter(|&&d| d != '_').collect::<String>();
        decimal_digits.parse().unwrap()
    }
}

// TODO SHOULD BE REFACTORED TO OctalLiteralPrefix OctalDigitOrUnderscore* OctalDigit OctalDigitOrUnderscore*
// OctalLiteralPrefix OctalDigitOrUnderscore*
pub(crate) OctalLiteral: u128 = {
    <octal_prefix:OctalLiteralPrefix> <octal_digits:OctalDigitOrUnderscore+> => {
        let mut octal_digits = octal_digits;
        octal_digits.reverse();
        let mut result = 0;
        let mut digit_count = 0;
        for (i, d) in octal_digits.iter().enumerate() {
            if d == &'_' {
                continue;
            }

            result += d.to_digit(8).unwrap() * 8_u32.pow(digit_count as u32);
            digit_count += 1;
        }
        result as u128
    }
}

// TODO in the future refactor to where BinaryLiteral is lexed with the following production:
// BinaryLiteral = BinaryLiteralPrefix BinaryDigitOrUnderscore* BinaryDigit BinaryDigitOrUnderscore*
// Currently this is not working (not sure why) so I am using the following production:
// BinaryLiteral = BinaryLiteralPrefix BinaryDigitOrUnderscore*
// However, this is not correct because it allows for `0b_` to be a valid binary literal. Right now this case is being parsed to 0.
// _ -> 0
pub(crate) BinaryLiteral: u128 = {
    <binary_prefix:BinaryLiteralPrefix> <binary_digits:BinaryDigitOrUnderscore+> => {
        // We must redeclare each of the variables coming from the nonterminals in the grammar as mutable, because they are immutable by default.
        let mut binary_digits = binary_digits;
        binary_digits.reverse();
        let mut result = 0;
        let mut digit_count = 0;
        for (i, d) in binary_digits.iter().enumerate() {
            if d == &'_' {
                continue;
            }
            result += d.to_digit(10).unwrap() * 2u32.pow(digit_count as u32);
            digit_count += 1;
        }
        result as u128
    }
}

// HexadecimalDigit | Underscore
pub(crate) HexadecimalDigitOrUnderscore: char = {
    <hexadecimal_digit:HexadecimalDigit> => hexadecimal_digit,
    <underscore:Underscore> => underscore,
}

// DecimalDigit | Underscore
pub(crate) DecimalDigitOrUnderscore: char = {
    <decimal_digit:DecimalDigit> => decimal_digit,
    <underscore:Underscore> => underscore,
}

// OctalDigit | Underscore
pub(crate) OctalDigitOrUnderscore: char = {
    <octal_digit:OctalDigit> => octal_digit,
    <underscore:Underscore> => underscore,
}

// BinaryDigit | Underscore
pub(crate) BinaryDigitOrUnderscore: char = {
    <binary_digit:BinaryDigit> => binary_digit,
    <underscore:Underscore> => underscore,
}

// "0".."9" | "a".."f" | "A".."F"
pub(crate) HexadecimalDigit: char = {
    <d:DecimalDigit> => d,
    <h:r"[a-fA-F]"> => h.chars().next().unwrap(),
}

// "0".."9"
pub(crate) DecimalDigit: char = {
    <o:OctalDigit> => o,
    <d:r"8|9"> => d.chars().next().unwrap(),
}

// "0".."7"
pub(crate) OctalDigit: char = {
    <b:BinaryDigit> => b,
    <o:r"2|3|4|5|6|7"> => o.chars().next().unwrap(),
}

// "0" | "1"
pub(crate) BinaryDigit: char = {
    <b:r"0|1"> => b.chars().next().unwrap(),
}

// "0b" | "0B"
pub(crate) BinaryLiteralPrefix: String = {
    <b:r"0b"> => b.to_string(),
    <b:r"0B"> => b.to_string(),
}

// "0o" | "0O"
pub(crate) OctalLiteralPrefix: String = {
    <o:r"0o"> => o.to_string(),
    <o:r"0O"> => o.to_string(),
}

// "0x" | "0X"
pub(crate) HexadecimalLiteralPrefix: String = {
    <h:r"0x"> => h.to_string(),
    <h:r"0X"> => h.to_string(),
}

// "u8" | "u16" | "u32" | "u64" | "u128" | "usize"
// | "i8" | "i16" | "i32" | "i64" | "i128" | "isize"
pub(crate) IntegerSuffix: String = {
    <integer_suffix:r"u8|u16|u32|u64|u128|usize|i8|i16|i32|i64|i128|isize"> => integer_suffix.to_string(),
}

////////////////////
// Float Literals //
////////////////////

pub(crate) FloatSuffix: String = {
    <float_suffix:r"f32|f64"> => float_suffix.to_string(),
}

////////////////////////////////////////////
// Punctuation symbol tokens              //
//                                        //
// "+" -> Plus: char                      //
// "-" -> Minus: char                     //
// "*" -> Star: char                      //
// "/" -> Slash: char                     //
// "%" -> Percent: char                   //
// "^" -> Caret: char                     //
// "! -> Not: char                        //
// "&" -> And: char                       //
// "|" -> Or: char                        //
// "&&" -> AndAnd: String                 //
// "||" -> OrOr: String                   //
// "+=" -> PlusEquals: String             //
// "-=" -> MinusEquals: String            //
// "*=" -> StarEquals: String             //
// "/=" -> SlashEquals: String            //
// "%=" -> PercentEquals: String          //
// "^=" -> CaretEquals: String            //
// "&=" -> AndEquals: String              //
// "|=" -> OrEquals: String               //
// "==" -> DoubleEquals: String           //
// "!=" -> NotEqual: String               //
// "<" -> LessThan: char                  //
// ">" -> GreaterThan: char               //
// "<=" | "≤" -> LessThanEqual: String    //
// ">=" | "≥" -> GreaterThanEqual: String //
////////////////////////////////////////////

pub(crate) Plus: char = {
    <plus:"+"> => plus.chars().next().unwrap(),
}
pub(crate) Minus: char = {
    <minus:"-"> => minus.chars().next().unwrap(),
}
pub(crate) Star: char = {
    <star:"*"> => star.chars().next().unwrap(),
}
pub(crate) Slash: char = {
    <slash:"/"> => slash.chars().next().unwrap(),
}
pub(crate) Percent: char = {
    <percent:"%"> => percent.chars().next().unwrap(),
}
pub(crate) Caret: char = {
    <caret:"^"> => caret.chars().next().unwrap(),
}
pub(crate) Not: char = {
    <not:"!"> => not.chars().next().unwrap(),
}
pub(crate) And: char = {
    <and:"&"> => and.chars().next().unwrap(),
}
pub(crate) Or: char = {
    <or:"|"> => or.chars().next().unwrap(),
}
pub(crate) AndAnd: String = {
    <and_and:"&&"> => and_and.to_string(),
}
pub(crate) OrOr: String = {
    <or_or:"||"> => or_or.to_string(),
}
pub(crate) MinusEquals: String = {
    <minus_equals:"-="> => minus_equals.to_string(),
}
pub(crate) StarEquals: String = {
    <star_equals:"*="> => star_equals.to_string(),
}
pub(crate) SlashEquals: String = {
    <slash_equals:"/="> => slash_equals.to_string(),
}
pub(crate) PercentEquals: String = {
    <percent_equals:"%="> => percent_equals.to_string(),
}
pub(crate) CaretEquals: String = {
    <caret_equals:"^="> => caret_equals.to_string(),
}
pub(crate) AndEquals: String = {
    <and_equals:"&="> => and_equals.to_string(),
}
pub(crate) OrEquals: String = {
    <or_equals:"|="> => or_equals.to_string(),
}
pub(crate) Equals: char = {
    <equals:"="> => equals.chars().next().unwrap(),
}
pub(crate) DoubleEquals: String = {
    <double_equals:"=="> => double_equals.to_string(),
}
pub(crate) NotEqual: String = {
    <not_equal:"!="> => not_equal.to_string(),
}
pub(crate) LessThan: char = {
    <less_than:"<"> => less_than.chars().next().unwrap(),
}
pub(crate) LessThanEqual: String = {
    <less_than_equal:"<="> => less_than_equal.to_string(),
    <less_than_equal:"≤"> => less_than_equal.to_string(),
}
pub(crate) GreaterThan: char = {
    <greater_than:">"> => greater_than.chars().next().unwrap(),
}
pub(crate) GreaterThanEqual: String = {
    <greater_than_equal:">="> => greater_than_equal.to_string(),
    <greater_than_equal:"≥"> => greater_than_equal.to_string(),
}
pub(crate) Underscore: char = {
    <underscore:"_"> => underscore.chars().next().unwrap(),
}
pub(crate) Dot: char = {
    <dot:"."> => dot.chars().next().unwrap(),
}
pub(crate) DotDot: String = {
    <dot_dot:".."> => dot_dot.to_string(),
}
pub(crate) DotDotDot: String = {
    <dot_dot_dot:"..."> => dot_dot_dot.to_string(),
}
pub(crate) DotDotEquals: String = {
    <dot_dot_equals:"..="> => dot_dot_equals.to_string(),
}
pub(crate) Comma: char = {
    <comma:","> => comma.chars().next().unwrap(),
}
pub(crate) Colon: char = {
    <colon:":"> => colon.chars().next().unwrap(),
}
pub(crate) Semicolon: char = {
    <semicolon:";"> => semicolon.chars().next().unwrap(),
}
pub(crate) PathSeparator: String = {
    <path_separator:"::"> => path_separator.to_string(),
}
pub(crate) RightArrow: String = {
    <right_arrow:"->"> => right_arrow.to_string(),
}
pub(crate) FatArrow: String = {
    <fat_arrow:"=>"> => fat_arrow.to_string(),
}
pub(crate) Pound: char = {
    <pound:"#"> => pound.chars().next().unwrap(),
}
pub(crate) Dollar: char = {
    <dollar:"$"> => dollar.chars().next().unwrap(),
}
pub(crate) Question: char = {
    <question:"?"> => question.chars().next().unwrap(),
}

///////////////////////////////
// Delimiter symbol tokens   //
//                           //
// "(" -> LeftParen: char    //
// ")" -> RightParen: char   //
// "[" -> LeftBracket: char  //
// "]" -> RightBracket: char //
// "{" -> LeftBrace: char    //
// "}" -> RightBrace: char   //
///////////////////////////////

pub(crate) LeftParen: char = {
    <left_paren:"("> => left_paren.chars().next().unwrap(),
}
pub(crate) RightParen: char = {
    <right_paren:")"> => right_paren.chars().next().unwrap(),
}
pub(crate) LeftBracket: char = {
    <left_bracket:"["> => left_bracket.chars().next().unwrap(),
}
pub(crate) RightBracket: char = {
    <right_bracket:"]"> => right_bracket.chars().next().unwrap(),
}
pub(crate) LeftBrace: char = {
    <left_brace:"{"> => left_brace.chars().next().unwrap(),
}
pub(crate) RightBrace: char = {
    <right_brace:"}"> => right_brace.chars().next().unwrap(),
}

match {
    r"\s*" => {}, // ignore whitespace
    // r"//.*" => {}, // ignore comments
    r"//[^\n\r]*[\n\r]*" => {}, // ignore comments
    // This `_` means "add in all the other strings and
    // regular expressions in the grammer here" (e.g.,
    // `(`).
    _
}
